import d3Scale from 'd3-scale';
import events from 'events';

import Keyboard from '../interactions/keyboard';
import Surface from '../interactions/surface';
import View from './view';
import ViewCollection from './view-collection';


/**
 * The `timeline` is the main entry point of a temporal visualization.
 *
 * The `timeline`:
 * - contains factories to manage its `views` and `layers`,
 * - is the central hub for all user interaction events (keyboard, mouse),
 * - holds the current interaction `state` which defines how the different timeline elements (views, layers, shapes) respond to those events.
 */
export default class Timeline extends events.EventEmitter {
  /**
   * Creates a new `Timeline` instance
   */
  constructor() {
    super();

    this._views = new ViewCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, 'body');

    // init default configuration for views factory
    this._viewsConfiguration = {};
    this.configureViews();
    // stores
    this._viewsById = {};
    this._groupedLayers = {};
  }

  /**
   * Factory method to add interaction modules the timeline should listen to.
   * By default, the timeline listen to Keyboard, and instance a Surface on each container
   * @param {EventSource} ctor - the contructor of the interaction module to instanciate
   * @param el {DOMElement} the DOM element to bind to the EventSource module
   * @param options {Object} options to be applied to the ctor (defaults to `{}`)
   */
  _createInteraction(ctor, el, options = {}) {
    const interaction = new ctor(el, options);
    interaction.on('event', this._handleEvent);
  }

  /**
   * The callback that is used to listen to interactions modules
   * @params {Event} e - a custom event generated by interaction modules
   */
  _handleEvent(e) {
    // emit event as a middleware
    this.emit('event', e);
    // propagate to the state
    if (!this._state) { return; }
    this._state.handleEvent(e);
  }


  /**
   * Changes the state of the timeline
   * @param {BaseState} state - the state in which the timeline must be setted
   */
  set state(state) {
    if (this._state) { this._state.exit(); }
    this._state = state;
    this._state.enter();
  }

  get state() {
    return this._state;
  }

  /**
   * Shortcut to access the View collection
   * @return {ViewCollection}
   */
  get views() {
    return this._views;
  }

  /**
   * Shortcut to access the Layer list
   * @return {Array}
   */
  get layers() {
    return this._views.layers;
  }

  /**
   * Adds a `View` instance to the timeline
   * @param {View} view
   */
  add(view) {
    if (this.views.indexOf(view) !== -1) {
      throw new Error('view already added to the timeline');
    }

    this.views.push(view);
    this._createInteraction(Surface, view.$el);
  }

  remove(view) {
    // @TODO
  }

  /**
   * Defines a default for each view to be created
   * @param {Number} pixelsPerSeconds
   * @param {Number} width
   * @param {Number} height
   */
  configureViews(pixelsPerSecond = 100, width = 1000, height = 120) {
    this._viewsConfiguration = { pixelsPerSecond, width, height };
  }

  /**
   * Creates a new view from the configuration define in `configureViews`
   * @param {DOMElement} $el - the element to insert the view inside
   * @param {Object} options - override the defaults options if necessary
   * @param {String} [viewId=null] - optionnal id to give to the view, only exists in timeline's context
   * @return {View}
   */
  createView($el, options = {}, viewId = null) {
    const config = Object.assign({}, this._viewsConfiguration, options);
    const { pixelsPerSecond, width, height } = config;
    const view = new View($el, pixelsPerSecond, width, height);

    if (viewId !== null) {
      if (this._viewsById[viewId] !== undefined) {
        throw new Error(`viewId: "${viewId}" is already used`);
      }

      this._viewsById[viewId] = view;
    }
    // add view to the timeline
    this.add(view);
    return view;
  }

  /**
   * Adds a layer to a view, allow to group view arbitrarily inside groups. Basically a wrapper for `view.add(layer)`
   * @param {Layer} layer - the layer to add
   * @param {View} view - the view to the insert the layer in
   * @param {String} [groupId='default'] - the group in which associate the layer
   */
  addLayer(layer, viewOrViewId, groupId = 'default') {
    let view = viewOrViewId;

    if (typeof viewOrViewId === 'string') {
      view = this.getViewById(viewOrViewId);
    }
    // we should have a View instance at this point
    view.add(layer);

    if (!this._groupedLayers[groupId]) {
      this._groupedLayers[groupId] = [];
    }

    this._groupedLayers[groupId].push(layer);
  }

  /**
   * Removes a layer from its view (the layer is detatched from the DOM but can still be reused)
   * @param {Layer} layer - the layer to remove
   */
  removeLayer(layer) {
    this.views.forEach(function(view) {
      const index = view.layers.indexOf(layer);
      if (index !== -1) { view.remove(layer); }
    });

    for (let groupId in this._groupedLayers) {
      const group = this._groupedLayers[groupId];
      const index = group.indexOf(layer);

      if (index !== -1) { group.splice(layer, 1); }

      if (!group.length) {
        delete this._groupedLayers[groupId];
      }
    }
  }

  /**
   * Returns a view from it's id
   * @param {String} viewId
   * @return {View}
   */
  getViewById(viewId) {
    return this._viewsById[viewId];
  }

  /**
   * Returns an array of layers from their group Id
   * @param {String} groupId
   * @return {Array}
   */
  getLayersByGroup(groupId) {
    return this._groupedLayers[groupId];
  }

  *[Symbol.iterator]() {
    yield* this.views[Symbol.iterator]();
  }
}

import d3Scale from 'd3-scale';
import events from 'events';

import Keyboard from '../interactions/keyboard';
import Surface from '../interactions/surface';
import View from './view';
import ViewCollection from './view-collection';


/**
 * The `Timeline` class is the main entry point to create a representation of temporal data.
 * A `Timeline` instance can have multiples `View` instances, which are basically a view window on the overall timeline.
 *
 * The timeline hold the current interaction state and is the central hub for keyboard as well as mouse events.
 * States are there to facilitating interactions with the timeline for:
 * - zooming
 * - moving
 * - editing
 *
 * Methods `register`, `render` and `update` call the same methods on all the `View` instances, which call the same methods one on all its `Layer` instances.
 * - `register`: registers a `View` instance onto the timeline (ie. the timeline can `render` and `update` its different views)
 * - `render`: renders the DOM for the element (if has one) and its descendant (here renders the views, ie. render the DOM tree for a view and attach it in the DOM at the right place)
 * - `update`: update the display according to data changes (ie. update the DOM element attached to the DOM tree with render method, based on new data).
 */
export default class Timeline extends events.EventEmitter {
  /**
   * Creates a new `Timeline` instance
   */
  constructor() {
    super();

    this._views = new ViewCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, 'body');

    // init default configuration for views factory
    this._viewsConfiguration = {};
    this.configureViews();
    // stores
    this._viewsById = {};
    this._groupedLayers = {};
  }

  /**
   * Factory method to add interaction modules the timeline should listen to.
   * By default, the timeline listen to Keyboard, and instance a Surface on each container
   * @param {EventSource} ctor - the contructor of the interaction module to instanciate
   * @param el {DOMElement} the DOM element to bind to the EventSource module
   * @param options {Object} options to be applied to the ctor (defaults to `{}`)
   */
  _createInteraction(ctor, el, options = {}) {
    const interaction = new ctor(el, options);
    interaction.on('event', this._handleEvent);
  }

  /**
   * The callback that is used to listen to interactions modules
   * @params {Event} e - a custom event generated by interaction modules
   */
  _handleEvent(e) {
    // emit event as a middleware
    this.emit('event', e);
    // propagate to the state
    if (!this._state) { return; }
    this._state.handleEvent(e);
  }


  /**
   * Changes the state of the timeline.
   * `State` instances are used to define the application logic by precising specific user interaction cases, and how they impact the overal temporal data representation.
   *
   * @param {BaseState} state - the state in which the timeline must be setted
   */
  set state(state) {
    if (this._state) { this._state.exit(); }
    this._state = state;
    this._state.enter();
  }

  get state() {
    return this._state;
  }

  /**
   *  Shortcut to access the View collection
   *  @return {ViewCollection}
   */
  get views() {
    return this._views;
  }

  /**
   *  Shortcut to access the Layer list
   *  @return {Array}
   */
  get layers() {
    return this._views.layers;
  }

  /**
   * Adds a view to the timeline
   * Views display this window on the timeline in theirs own SVG element.
   * @param {View} view
   */
  add(view) {
    if (this.views.indexOf(view) !== -1) {
      throw new Error('view already added to the timeline');
    }

    this.views.push(view);
    this._createInteraction(Surface, view.$el);
  }

  remove(view) {
    // @TODO
  }

  /**
   *  Defines a default for each view to be created
   *  @param {Number} pixelsPerSeconds
   *  @param {Number} width
   *  @param {Number} height
   */
  configureViews(pixelsPerSecond = 100, width = 1000, height = 120) {
    this._viewsConfiguration = { pixelsPerSecond, width, height };
  }

  /**
   *  Creates a new view from the configuration define in `configureViews`
   *  @param {DOMElement} $el - the element to insert the view inside
   *  @param {Object} options - override the defaults options if necessary
   *  @param {String} [viewId=null] - optionnal id to give to the view, only exists in timeline's context
   *  @return {View}
   */
  createView($el, options = {}, viewId = null) {
    const config = Object.assign({}, this._viewsConfiguration, options);
    const { pixelsPerSecond, width, height } = config;
    const view = new View($el, pixelsPerSecond, width, height);

    if (viewId !== null) {
      if (this._viewsById[viewId] !== undefined) {
        throw new Error(`viewId: "${viewId}" is already used`);
      }

      this._viewsById[viewId] = view;
    }
    // add view to the timeline
    this.add(view);
    return view;
  }

  /**
   *  Adds a layer to a view, allow to group view arbitrarily inside groups. Basically a wrapper for `view.add(layer)`
   *  @param {Layer} layer - the layer to add
   *  @param {View} view - the view to the insert the layer in
   *  @param {String} [groupId='default'] - the group in which associate the layer
   */
  addLayer(layer, viewOrViewId, groupId = 'default') {
    let view = viewOrViewId;

    if (typeof viewOrViewId === 'string') {
      view = this.getViewById(viewOrViewId);
    }
    // we should have a View instance at this point
    view.add(layer);

    if (!this._groupedLayers[groupId]) {
      this._groupedLayers[groupId] = [];
    }

    this._groupedLayers[groupId].push(layer);
  }

  /**
   *  Removes a layer from its view (the layer is detatched from the DOM but can still be reused)
   *  @param {Layer} layer - the layer to remove
   */
  removeLayer(layer) {
    this.views.forEach(function(view) {
      const index = view.layers.indexOf(layer);
      if (index !== -1) { view.remove(layer); }
    });

    for (let groupId in this._groupedLayers) {
      const group = this._groupedLayers[groupId];
      const index = group.indexOf(layer);

      if (index !== -1) { group.splice(layer, 1); }

      if (!group.length) {
        delete this._groupedLayers[groupId];
      }
    }
  }

  /**
   *  Returns a view from it's id
   *  @param {String} viewId
   *  @return {View}
   */
  getViewById(viewId) {
    return this._viewsById[viewId];
  }

  /**
   *  Returns an array of layers from their group Id
   *  @param {String} groupId
   *  @return {Array}
   */
  getLayersByGroup(groupId) {
    return this._groupedLayers[groupId];
  }

  *[Symbol.iterator]() {
    yield* this.views[Symbol.iterator]();
  }
}

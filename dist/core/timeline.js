"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _get = require("babel-runtime/helpers/get")["default"];

var _createComputedClass = require("babel-runtime/helpers/create-computed-class")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequire = require("babel-runtime/helpers/interop-require")["default"];

var d3Scale = _interopRequire(require("d3-scale"));

var events = _interopRequire(require("events"));

var Keyboard = _interopRequire(require("../interactions/keyboard"));

var Surface = _interopRequire(require("../interactions/surface"));

var View = _interopRequire(require("./view"));

var ViewCollection = _interopRequire(require("./view-collection"));

/**
 * The `Timeline` class is the main entry point to create a representation of temporal data.
 * A `Timeline` instance can have multiples `View` instances, which are basically a view window on the overall timeline.
 *
 * The timeline hold the current interaction state and is the central hub for keyboard as well as mouse events.
 * States are there to facilitating interactions with the timeline for:
 * - zooming
 * - moving
 * - editing
 *
 * Methods `register`, `render` and `update` call the same methods on all the `View` instances, which call the same methods one on all its `Layer` instances.
 * - `register`: registers a `View` instance onto the timeline (ie. the timeline can `render` and `update` its different views)
 * - `render`: renders the DOM for the element (if has one) and its descendant (here renders the views, ie. render the DOM tree for a view and attach it in the DOM at the right place)
 * - `update`: update the display according to data changes (ie. update the DOM element attached to the DOM tree with render method, based on new data).
 */

var Timeline = (function (_events$EventEmitter) {
  /**
   * Creates a new `Timeline` instance
   */

  function Timeline() {
    _classCallCheck(this, Timeline);

    _get(_core.Object.getPrototypeOf(Timeline.prototype), "constructor", this).call(this);

    this._views = new ViewCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, "body");

    // init default configuration for views factory
    this._viewsConfiguration = {};
    this.configureViews();
    // stores
    this._viewsById = {};
    this._groupedLayers = {};
  }

  _inherits(Timeline, _events$EventEmitter);

  _createComputedClass(Timeline, [{
    key: "_createInteraction",

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline listen to Keyboard, and instance a Surface on each container
     * @param {EventSource} ctor - the contructor of the interaction module to instanciate
     * @param el {DOMElement} the DOM element to bind to the EventSource module
     * @param options {Object} options to be applied to the ctor (defaults to `{}`)
     */
    value: function _createInteraction(ctor, el) {
      var options = arguments[2] === undefined ? {} : arguments[2];

      var interaction = new ctor(el, options);
      interaction.on("event", this._handleEvent);
    }
  }, {
    key: "_handleEvent",

    /**
     * The callback that is used to listen to interactions modules
     * @params {Event} e - a custom event generated by interaction modules
     */
    value: function _handleEvent(e) {
      // emit event as a middleware
      this.emit("event", e);
      // propagate to the state
      if (!this._state) {
        return;
      }
      this._state.handleEvent(e);
    }
  }, {
    key: "state",

    /**
     * Changes the state of the timeline.
     * `State` instances are used to define the application logic by precising specific user interaction cases, and how they impact the overal temporal data representation.
     *
     * @param {BaseState} state - the state in which the timeline must be setted
     */
    set: function (state) {
      if (this._state) {
        this._state.exit();
      }
      this._state = state;
      this._state.enter();
    },
    get: function () {
      return this._state;
    }
  }, {
    key: "views",
    get: function () {
      return this._views;
    }
  }, {
    key: "layers",
    get: function () {
      return this._views.layers;
    }
  }, {
    key: "add",

    /**
     * Adds a view to the timeline
     * Views display this window on the timeline in theirs own SVG element.
     * @param {View} view
     */
    value: function add(view) {
      if (this.views.indexOf(view) !== -1) {
        throw new Error("view already added to the timeline");
      }

      this.views.push(view);
      this._createInteraction(Surface, view.$el);
    }
  }, {
    key: "remove",
    value: function remove(view) {}
  }, {
    key: "configureViews",

    /**
     *  Defines a default for each view to be created
     *  @param {Number} pixelsPerSeconds
     *  @param {Number} width
     *  @param {Number} height
     */
    value: function configureViews() {
      var pixelsPerSecond = arguments[0] === undefined ? 100 : arguments[0];
      var width = arguments[1] === undefined ? 1000 : arguments[1];
      var height = arguments[2] === undefined ? 120 : arguments[2];

      this._viewsConfiguration = { pixelsPerSecond: pixelsPerSecond, width: width, height: height };
    }
  }, {
    key: "createView",

    /**
     *  Creates a new view from the configuration define in `configureViews`
     *  @param {DOMElement} $el - the element to insert the view inside
     *  @param {Object} options - override the defaults options if necessary
     *  @param {String} [viewId=null] - optionnal id to give to the view, only exists in timeline's context
     *  @return {View}
     */
    value: function createView($el) {
      var options = arguments[1] === undefined ? {} : arguments[1];
      var viewId = arguments[2] === undefined ? null : arguments[2];

      var config = _core.Object.assign({}, this._viewsConfiguration, options);
      var pixelsPerSecond = config.pixelsPerSecond;
      var width = config.width;
      var height = config.height;

      var view = new View($el, pixelsPerSecond, width, height);

      if (viewId !== null) {
        if (this._viewsById[viewId] !== undefined) {
          throw new Error("viewId: \"" + viewId + "\" is already used");
        }

        this._viewsById[viewId] = view;
      }
      // add view to the timeline
      this.add(view);
      return view;
    }
  }, {
    key: "addLayer",

    /**
     *  Adds a layer to a view, allow to group view arbitrarily inside groups. Basically a wrapper for `view.add(layer)`
     *  @param {Layer} layer - the layer to add
     *  @param {View} view - the view to the insert the layer in
     *  @param {String} [groupId='default'] - the group in which associate the layer
     */
    value: function addLayer(layer, viewOrViewId) {
      var groupId = arguments[2] === undefined ? "default" : arguments[2];

      var view = viewOrViewId;

      if (typeof viewOrViewId === "string") {
        view = this.getViewById(viewOrViewId);
      }
      // we should have a View instance at this point
      view.add(layer);

      if (!this._groupedLayers[groupId]) {
        this._groupedLayers[groupId] = [];
      }

      this._groupedLayers[groupId].push(layer);
    }
  }, {
    key: "removeLayer",

    /**
     *  Removes a layer from its view (the layer is detatched from the DOM but can still be reused)
     *  @param {Layer} layer - the layer to remove
     */
    value: function removeLayer(layer) {
      this.views.forEach(function (view) {
        var index = view.layers.indexOf(layer);
        if (index !== -1) {
          view.remove(layer);
        }
      });

      for (var groupId in this._groupedLayers) {
        var group = this._groupedLayers[groupId];
        var index = group.indexOf(layer);

        if (index !== -1) {
          group.splice(layer, 1);
        }

        if (!group.length) {
          delete this._groupedLayers[groupId];
        }
      }
    }
  }, {
    key: "getViewById",

    /**
     *  Returns a view from it's id
     *  @param {String} viewId
     *  @return {View}
     */
    value: function getViewById(viewId) {
      return this._viewsById[viewId];
    }
  }, {
    key: "getLayersByGroup",

    /**
     *  Returns an array of layers from their group Id
     *  @param {String} groupId
     *  @return {Array}
     */
    value: function getLayersByGroup(groupId) {
      return this._groupedLayers[groupId];
    }
  }, {
    key: _core.Symbol.iterator,
    value: _regeneratorRuntime.mark(function callee$1$0() {
      var _this = this;

      return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_core.$for.getIterator(_this.views), "t215", 1);

          case 1:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    })
  }]);

  return Timeline;
})(events.EventEmitter);

module.exports = Timeline;

// @TODO
//# sourceMappingURL=data:application/json;base64,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QUM7S0FDaEM7Ozs7Ozs7OztXQU9lLDBCQUFDLE9BQU8sRUFBRTtBQUN4QixhQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDckM7O1NBRUMsTUFBQSxNQUFNLENBQUMsUUFBUTtvQ0FBQzs7Ozs7O29FQUNULE1BQUssS0FBSzs7Ozs7OztLQUNsQjs7O1NBMUxrQixRQUFRO0dBQVMsTUFBTSxDQUFDLFlBQVk7O2lCQUFwQyxRQUFRIiwiZmlsZSI6ImVzNi9jb3JlL3RpbWVsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGQzU2NhbGUgZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuXG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2tleWJvYXJkJztcbmltcG9ydCBTdXJmYWNlIGZyb20gJy4uL2ludGVyYWN0aW9ucy9zdXJmYWNlJztcbmltcG9ydCBWaWV3IGZyb20gJy4vdmlldyc7XG5pbXBvcnQgVmlld0NvbGxlY3Rpb24gZnJvbSAnLi92aWV3LWNvbGxlY3Rpb24nO1xuXG5cbi8qKlxuICogVGhlIGBUaW1lbGluZWAgY2xhc3MgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgdG8gY3JlYXRlIGEgcmVwcmVzZW50YXRpb24gb2YgdGVtcG9yYWwgZGF0YS5cbiAqIEEgYFRpbWVsaW5lYCBpbnN0YW5jZSBjYW4gaGF2ZSBtdWx0aXBsZXMgYFZpZXdgIGluc3RhbmNlcywgd2hpY2ggYXJlIGJhc2ljYWxseSBhIHZpZXcgd2luZG93IG9uIHRoZSBvdmVyYWxsIHRpbWVsaW5lLlxuICpcbiAqIFRoZSB0aW1lbGluZSBob2xkIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIHN0YXRlIGFuZCBpcyB0aGUgY2VudHJhbCBodWIgZm9yIGtleWJvYXJkIGFzIHdlbGwgYXMgbW91c2UgZXZlbnRzLlxuICogU3RhdGVzIGFyZSB0aGVyZSB0byBmYWNpbGl0YXRpbmcgaW50ZXJhY3Rpb25zIHdpdGggdGhlIHRpbWVsaW5lIGZvcjpcbiAqIC0gem9vbWluZ1xuICogLSBtb3ZpbmdcbiAqIC0gZWRpdGluZ1xuICpcbiAqIE1ldGhvZHMgYHJlZ2lzdGVyYCwgYHJlbmRlcmAgYW5kIGB1cGRhdGVgIGNhbGwgdGhlIHNhbWUgbWV0aG9kcyBvbiBhbGwgdGhlIGBWaWV3YCBpbnN0YW5jZXMsIHdoaWNoIGNhbGwgdGhlIHNhbWUgbWV0aG9kcyBvbmUgb24gYWxsIGl0cyBgTGF5ZXJgIGluc3RhbmNlcy5cbiAqIC0gYHJlZ2lzdGVyYDogcmVnaXN0ZXJzIGEgYFZpZXdgIGluc3RhbmNlIG9udG8gdGhlIHRpbWVsaW5lIChpZS4gdGhlIHRpbWVsaW5lIGNhbiBgcmVuZGVyYCBhbmQgYHVwZGF0ZWAgaXRzIGRpZmZlcmVudCB2aWV3cylcbiAqIC0gYHJlbmRlcmA6IHJlbmRlcnMgdGhlIERPTSBmb3IgdGhlIGVsZW1lbnQgKGlmIGhhcyBvbmUpIGFuZCBpdHMgZGVzY2VuZGFudCAoaGVyZSByZW5kZXJzIHRoZSB2aWV3cywgaWUuIHJlbmRlciB0aGUgRE9NIHRyZWUgZm9yIGEgdmlldyBhbmQgYXR0YWNoIGl0IGluIHRoZSBET00gYXQgdGhlIHJpZ2h0IHBsYWNlKVxuICogLSBgdXBkYXRlYDogdXBkYXRlIHRoZSBkaXNwbGF5IGFjY29yZGluZyB0byBkYXRhIGNoYW5nZXMgKGllLiB1cGRhdGUgdGhlIERPTSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSBET00gdHJlZSB3aXRoIHJlbmRlciBtZXRob2QsIGJhc2VkIG9uIG5ldyBkYXRhKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFRpbWVsaW5lYCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3ZpZXdzID0gbmV3IFZpZXdDb2xsZWN0aW9uKHRoaXMpO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX2hhbmRsZUV2ZW50ID0gdGhpcy5faGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jcmVhdGVJbnRlcmFjdGlvbihLZXlib2FyZCwgJ2JvZHknKTtcblxuICAgIC8vIGluaXQgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciB2aWV3cyBmYWN0b3J5XG4gICAgdGhpcy5fdmlld3NDb25maWd1cmF0aW9uID0ge307XG4gICAgdGhpcy5jb25maWd1cmVWaWV3cygpO1xuICAgIC8vIHN0b3Jlc1xuICAgIHRoaXMuX3ZpZXdzQnlJZCA9IHt9O1xuICAgIHRoaXMuX2dyb3VwZWRMYXllcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBhZGQgaW50ZXJhY3Rpb24gbW9kdWxlcyB0aGUgdGltZWxpbmUgc2hvdWxkIGxpc3RlbiB0by5cbiAgICogQnkgZGVmYXVsdCwgdGhlIHRpbWVsaW5lIGxpc3RlbiB0byBLZXlib2FyZCwgYW5kIGluc3RhbmNlIGEgU3VyZmFjZSBvbiBlYWNoIGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlfSBjdG9yIC0gdGhlIGNvbnRydWN0b3Igb2YgdGhlIGludGVyYWN0aW9uIG1vZHVsZSB0byBpbnN0YW5jaWF0ZVxuICAgKiBAcGFyYW0gZWwge0RPTUVsZW1lbnR9IHRoZSBET00gZWxlbWVudCB0byBiaW5kIHRvIHRoZSBFdmVudFNvdXJjZSBtb2R1bGVcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gb3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBjdG9yIChkZWZhdWx0cyB0byBge31gKVxuICAgKi9cbiAgX2NyZWF0ZUludGVyYWN0aW9uKGN0b3IsIGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpbnRlcmFjdGlvbiA9IG5ldyBjdG9yKGVsLCBvcHRpb25zKTtcbiAgICBpbnRlcmFjdGlvbi5vbignZXZlbnQnLCB0aGlzLl9oYW5kbGVFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB0byBsaXN0ZW4gdG8gaW50ZXJhY3Rpb25zIG1vZHVsZXNcbiAgICogQHBhcmFtcyB7RXZlbnR9IGUgLSBhIGN1c3RvbSBldmVudCBnZW5lcmF0ZWQgYnkgaW50ZXJhY3Rpb24gbW9kdWxlc1xuICAgKi9cbiAgX2hhbmRsZUV2ZW50KGUpIHtcbiAgICAvLyBlbWl0IGV2ZW50IGFzIGEgbWlkZGxld2FyZVxuICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBlKTtcbiAgICAvLyBwcm9wYWdhdGUgdG8gdGhlIHN0YXRlXG4gICAgaWYgKCF0aGlzLl9zdGF0ZSkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9zdGF0ZS5oYW5kbGVFdmVudChlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHN0YXRlIG9mIHRoZSB0aW1lbGluZS5cbiAgICogYFN0YXRlYCBpbnN0YW5jZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBhcHBsaWNhdGlvbiBsb2dpYyBieSBwcmVjaXNpbmcgc3BlY2lmaWMgdXNlciBpbnRlcmFjdGlvbiBjYXNlcywgYW5kIGhvdyB0aGV5IGltcGFjdCB0aGUgb3ZlcmFsIHRlbXBvcmFsIGRhdGEgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZVN0YXRlfSBzdGF0ZSAtIHRoZSBzdGF0ZSBpbiB3aGljaCB0aGUgdGltZWxpbmUgbXVzdCBiZSBzZXR0ZWRcbiAgICovXG4gIHNldCBzdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSkgeyB0aGlzLl9zdGF0ZS5leGl0KCk7IH1cbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX3N0YXRlLmVudGVyKCk7XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgZ2V0IHZpZXdzKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cztcbiAgfVxuXG4gIGdldCBsYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdzLmxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmlldyB0byB0aGUgdGltZWxpbmVcbiAgICogVmlld3MgZGlzcGxheSB0aGlzIHdpbmRvdyBvbiB0aGUgdGltZWxpbmUgaW4gdGhlaXJzIG93biBTVkcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gICAqL1xuICBhZGQodmlldykge1xuICAgIGlmICh0aGlzLnZpZXdzLmluZGV4T2YodmlldykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZXcgYWxyZWFkeSBhZGRlZCB0byB0aGUgdGltZWxpbmUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdzLnB1c2godmlldyk7XG4gICAgdGhpcy5fY3JlYXRlSW50ZXJhY3Rpb24oU3VyZmFjZSwgdmlldy4kZWwpO1xuICB9XG5cbiAgcmVtb3ZlKHZpZXcpIHtcbiAgICAvLyBAVE9ET1xuICB9XG5cbiAgLyoqXG4gICAqICBEZWZpbmVzIGEgZGVmYXVsdCBmb3IgZWFjaCB2aWV3IHRvIGJlIGNyZWF0ZWRcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBwaXhlbHNQZXJTZWNvbmRzXG4gICAqICBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIGNvbmZpZ3VyZVZpZXdzKHBpeGVsc1BlclNlY29uZCA9IDEwMCwgd2lkdGggPSAxMDAwLCBoZWlnaHQgPSAxMjApIHtcbiAgICB0aGlzLl92aWV3c0NvbmZpZ3VyYXRpb24gPSB7IHBpeGVsc1BlclNlY29uZCwgd2lkdGgsIGhlaWdodCB9O1xuICB9XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGEgbmV3IHZpZXcgZnJvbSB0aGUgY29uZmlndXJhdGlvbiBkZWZpbmUgaW4gYGNvbmZpZ3VyZVZpZXdzYFxuICAgKiAgQHBhcmFtIHtET01FbGVtZW50fSAkZWwgLSB0aGUgZWxlbWVudCB0byBpbnNlcnQgdGhlIHZpZXcgaW5zaWRlXG4gICAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG92ZXJyaWRlIHRoZSBkZWZhdWx0cyBvcHRpb25zIGlmIG5lY2Vzc2FyeVxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFt2aWV3SWQ9bnVsbF0gLSBvcHRpb25uYWwgaWQgdG8gZ2l2ZSB0byB0aGUgdmlldywgb25seSBleGlzdHMgaW4gdGltZWxpbmUncyBjb250ZXh0XG4gICAqICBAcmV0dXJuIHtWaWV3fVxuICAgKi9cbiAgY3JlYXRlVmlldygkZWwsIG9wdGlvbnMgPSB7fSwgdmlld0lkID0gbnVsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdzQ29uZmlndXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBwaXhlbHNQZXJTZWNvbmQsIHdpZHRoLCBoZWlnaHQgfSA9IGNvbmZpZztcbiAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcoJGVsLCBwaXhlbHNQZXJTZWNvbmQsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKHZpZXdJZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX3ZpZXdzQnlJZFt2aWV3SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2aWV3SWQ6IFwiJHt2aWV3SWR9XCIgaXMgYWxyZWFkeSB1c2VkYCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZpZXdzQnlJZFt2aWV3SWRdID0gdmlldztcbiAgICB9XG4gICAgLy8gYWRkIHZpZXcgdG8gdGhlIHRpbWVsaW5lXG4gICAgdGhpcy5hZGQodmlldyk7XG4gICAgcmV0dXJuIHZpZXc7XG4gIH1cblxuICAvKipcbiAgICogIEFkZHMgYSBsYXllciB0byBhIHZpZXcsIGFsbG93IHRvIGdyb3VwIHZpZXcgYXJiaXRyYXJpbHkgaW5zaWRlIGdyb3Vwcy4gQmFzaWNhbGx5IGEgd3JhcHBlciBmb3IgYHZpZXcuYWRkKGxheWVyKWBcbiAgICogIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gdGhlIGxheWVyIHRvIGFkZFxuICAgKiAgQHBhcmFtIHtWaWV3fSB2aWV3IC0gdGhlIHZpZXcgdG8gdGhlIGluc2VydCB0aGUgbGF5ZXIgaW5cbiAgICogIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBJZD0nZGVmYXVsdCddIC0gdGhlIGdyb3VwIGluIHdoaWNoIGFzc29jaWF0ZSB0aGUgbGF5ZXJcbiAgICovXG4gIGFkZExheWVyKGxheWVyLCB2aWV3T3JWaWV3SWQsIGdyb3VwSWQgPSAnZGVmYXVsdCcpIHtcbiAgICBsZXQgdmlldyA9IHZpZXdPclZpZXdJZDtcblxuICAgIGlmICh0eXBlb2Ygdmlld09yVmlld0lkID09PSAnc3RyaW5nJykge1xuICAgICAgdmlldyA9IHRoaXMuZ2V0Vmlld0J5SWQodmlld09yVmlld0lkKTtcbiAgICB9XG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgYSBWaWV3IGluc3RhbmNlIGF0IHRoaXMgcG9pbnRcbiAgICB2aWV3LmFkZChsYXllcik7XG5cbiAgICBpZiAoIXRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF0pIHtcbiAgICAgIHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdLnB1c2gobGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqICBSZW1vdmVzIGEgbGF5ZXIgZnJvbSBpdHMgdmlldyAodGhlIGxheWVyIGlzIGRldGF0Y2hlZCBmcm9tIHRoZSBET00gYnV0IGNhbiBzdGlsbCBiZSByZXVzZWQpXG4gICAqICBAcGFyYW0ge0xheWVyfSBsYXllciAtIHRoZSBsYXllciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdmlldy5sYXllcnMuaW5kZXhPZihsYXllcik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7IHZpZXcucmVtb3ZlKGxheWVyKTsgfVxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgZ3JvdXBJZCBpbiB0aGlzLl9ncm91cGVkTGF5ZXJzKSB7XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF07XG4gICAgICBjb25zdCBpbmRleCA9IGdyb3VwLmluZGV4T2YobGF5ZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7IGdyb3VwLnNwbGljZShsYXllciwgMSk7IH1cblxuICAgICAgaWYgKCFncm91cC5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBSZXR1cm5zIGEgdmlldyBmcm9tIGl0J3MgaWRcbiAgICogIEBwYXJhbSB7U3RyaW5nfSB2aWV3SWRcbiAgICogIEByZXR1cm4ge1ZpZXd9XG4gICAqL1xuICBnZXRWaWV3QnlJZCh2aWV3SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3NCeUlkW3ZpZXdJZF07XG4gIH1cblxuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgbGF5ZXJzIGZyb20gdGhlaXIgZ3JvdXAgSWRcbiAgICogIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gICAqICBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldExheWVyc0J5R3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdO1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkKiB0aGlzLnZpZXdzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufVxuIl19
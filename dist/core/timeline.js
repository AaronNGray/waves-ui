"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _get = require("babel-runtime/helpers/get")["default"];

var _createComputedClass = require("babel-runtime/helpers/create-computed-class")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequire = require("babel-runtime/helpers/interop-require")["default"];

var d3Scale = _interopRequire(require("d3-scale"));

var events = _interopRequire(require("events"));

var Keyboard = _interopRequire(require("../interactions/keyboard"));

var Surface = _interopRequire(require("../interactions/surface"));

var View = _interopRequire(require("./view"));

var ViewCollection = _interopRequire(require("./view-collection"));

/**
 * The `Timeline` class is the main entry point to create a representation of temporal data.
 * A `Timeline` instance can have multiples `View` instances, which are basically a view window on the overall timeline.
 *
 * The timeline hold the current interaction state and is the central hub for keyboard as well as mouse events.
 * States are there to facilitating interactions with the timeline for:
 * - zooming
 * - moving
 * - editing
 *
 * Methods `register`, `render` and `update` call the same methods on all the `View` instances, which call the same methods one on all its `Layer` instances.
 * - `register`: registers a `View` instance onto the timeline (ie. the timeline can `render` and `update` its different views)
 * - `render`: renders the DOM for the element (if has one) and its descendant (here renders the views, ie. render the DOM tree for a view and attach it in the DOM at the right place)
 * - `update`: update the display according to data changes (ie. update the DOM element attached to the DOM tree with render method, based on new data).
 */

var Timeline = (function (_events$EventEmitter) {
  /**
   * Creates a new `Timeline` instance
   */

  function Timeline() {
    _classCallCheck(this, Timeline);

    _get(_core.Object.getPrototypeOf(Timeline.prototype), "constructor", this).call(this);

    this._views = new ViewCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, "body");
  }

  _inherits(Timeline, _events$EventEmitter);

  _createComputedClass(Timeline, [{
    key: "_createInteraction",

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline listen to Keyboard, and instance a Surface on each container
     * @param {EventSource} ctor - the contructor of the interaction module to instanciate
     * @param el {DOMElement} the DOM element to bind to the EventSource module
     * @param options {Object} options to be applied to the ctor (defaults to `{}`)
     */
    value: function _createInteraction(ctor, el) {
      var options = arguments[2] === undefined ? {} : arguments[2];

      var interaction = new ctor(el, options);
      interaction.on("event", this._handleEvent);
    }
  }, {
    key: "_handleEvent",

    /**
     * The callback that is used to listen to interactions modules
     * @params {Event} e - a custom event generated by interaction modules
     */
    value: function _handleEvent(e) {
      // emit event as a middleware
      this.emit("event", e);
      // propagate to the state
      if (!this._state) {
        return;
      }
      this._state.handleEvent(e);
    }
  }, {
    key: "state",

    /**
     * Changes the state of the timeline.
     * `State` instances are used to define the application logic by precising specific user interaction cases, and how they impact the overal temporal data representation.
     *
     * @param {BaseState} state - the state in which the timeline must be setted
     */
    set: function (state) {
      if (this._state) {
        this._state.exit();
      }
      this._state = state;
      this._state.enter();
    },
    get: function () {
      return this._state;
    }
  }, {
    key: "views",
    get: function () {
      return this._views;
    }
  }, {
    key: "layers",
    get: function () {
      return this._views.layers;
    }
  }, {
    key: "add",

    /**
     * Add a view to the timeline
     *
     * Views display this window on the timeline in theirs DOM SVG element.
     */
    value: function add(view) {
      this.views.push(view);
      this._createInteraction(Surface, view.$el);
    }
  }, {
    key: "remove",

    // @TODO
    value: function remove(view) {}
  }, {
    key: "configureViews",

    // @TODO - view factory
    // helpers
    value: function configureViews() {
      var pixelsPerSecond = arguments[0] === undefined ? 100 : arguments[0];
      var width = arguments[1] === undefined ? 1000 : arguments[1];
      var height = arguments[2] === undefined ? 120 : arguments[2];
    }
  }, {
    key: "createView",
    value: function createView($el) {
      var id = arguments[1] === undefined ? "default" : arguments[1];
      var height = arguments[2] === undefined ? 120 : arguments[2];
    }
  }, {
    key: "addLayer",
    value: function addLayer(layer) {
      var viewId = arguments[1] === undefined ? "default" : arguments[1];
      var group = arguments[2] === undefined ? "default" : arguments[2];
    }
  }, {
    key: "removeLayer",
    value: function removeLayer(layer) {}
  }, {
    key: _core.Symbol.iterator,
    value: _regeneratorRuntime.mark(function callee$1$0() {
      var _this = this;

      return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_core.$for.getIterator(_this.views), "t33", 1);

          case 1:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    })
  }]);

  return Timeline;
})(events.EventEmitter);

module.exports = Timeline;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVzNi9jb3JlL3RpbWVsaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBTyxPQUFPLDJCQUFNLFVBQVU7O0lBQ3ZCLE1BQU0sMkJBQU0sUUFBUTs7SUFFcEIsUUFBUSwyQkFBTSwwQkFBMEI7O0lBQ3hDLE9BQU8sMkJBQU0seUJBQXlCOztJQUN0QyxJQUFJLDJCQUFNLFFBQVE7O0lBQ2xCLGNBQWMsMkJBQU0sbUJBQW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQnpCLFFBQVE7Ozs7O0FBSWhCLFdBSlEsUUFBUSxHQUliOzBCQUpLLFFBQVE7O0FBS3pCLHFDQUxpQixRQUFRLDZDQUtqQjs7QUFFUixRQUFJLENBQUMsTUFBTSxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV2QyxRQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNuQixRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pELFFBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7R0FDM0M7O1lBWmtCLFFBQVE7O3VCQUFSLFFBQVE7Ozs7Ozs7Ozs7V0FxQlQsNEJBQUMsSUFBSSxFQUFFLEVBQUUsRUFBZ0I7VUFBZCxPQUFPLGdDQUFHLEVBQUU7O0FBQ3ZDLFVBQU0sV0FBVyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMxQyxpQkFBVyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzVDOzs7Ozs7OztXQU1XLHNCQUFDLENBQUMsRUFBRTs7QUFFZCxVQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFdEIsVUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFBRSxlQUFPO09BQUU7QUFDN0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDNUI7Ozs7Ozs7Ozs7U0FTUSxVQUFDLEtBQUssRUFBRTtBQUNmLFVBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUFFLFlBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7T0FBRTtBQUN4QyxVQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUNwQixVQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ3JCO1NBRVEsWUFBRztBQUNWLGFBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjs7O1NBRVEsWUFBRztBQUNWLGFBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUNwQjs7O1NBRVMsWUFBRztBQUNYLGFBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7S0FDM0I7Ozs7Ozs7OztXQU9FLGFBQUMsSUFBSSxFQUFFO0FBQ1IsVUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsVUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDNUM7Ozs7O1dBR0ssZ0JBQUMsSUFBSSxFQUFFLEVBRVo7Ozs7OztXQUlhLDBCQUFvRDtVQUFuRCxlQUFlLGdDQUFHLEdBQUc7VUFBRSxLQUFLLGdDQUFHLElBQUk7VUFBRSxNQUFNLGdDQUFHLEdBQUc7S0FFL0Q7OztXQUVTLG9CQUFDLEdBQUcsRUFBZ0M7VUFBOUIsRUFBRSxnQ0FBRyxTQUFTO1VBQUUsTUFBTSxnQ0FBRyxHQUFHO0tBRTNDOzs7V0FFTyxrQkFBQyxLQUFLLEVBQXlDO1VBQXZDLE1BQU0sZ0NBQUcsU0FBUztVQUFFLEtBQUssZ0NBQUcsU0FBUztLQUVwRDs7O1dBRVUscUJBQUMsS0FBSyxFQUFFLEVBRWxCOztTQUVDLE1BQUEsTUFBTSxDQUFDLFFBQVE7b0NBQUM7Ozs7OztvRUFDVCxNQUFLLEtBQUs7Ozs7Ozs7S0FDbEI7OztTQWxHa0IsUUFBUTtHQUFTLE1BQU0sQ0FBQyxZQUFZOztpQkFBcEMsUUFBUSIsImZpbGUiOiJlczYvY29yZS90aW1lbGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkM1NjYWxlIGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IEtleWJvYXJkIGZyb20gJy4uL2ludGVyYWN0aW9ucy9rZXlib2FyZCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvc3VyZmFjZSc7XG5pbXBvcnQgVmlldyBmcm9tICcuL3ZpZXcnO1xuaW1wb3J0IFZpZXdDb2xsZWN0aW9uIGZyb20gJy4vdmlldy1jb2xsZWN0aW9uJztcblxuXG4vKipcbiAqIFRoZSBgVGltZWxpbmVgIGNsYXNzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IHRvIGNyZWF0ZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRlbXBvcmFsIGRhdGEuXG4gKiBBIGBUaW1lbGluZWAgaW5zdGFuY2UgY2FuIGhhdmUgbXVsdGlwbGVzIGBWaWV3YCBpbnN0YW5jZXMsIHdoaWNoIGFyZSBiYXNpY2FsbHkgYSB2aWV3IHdpbmRvdyBvbiB0aGUgb3ZlcmFsbCB0aW1lbGluZS5cbiAqXG4gKiBUaGUgdGltZWxpbmUgaG9sZCB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBzdGF0ZSBhbmQgaXMgdGhlIGNlbnRyYWwgaHViIGZvciBrZXlib2FyZCBhcyB3ZWxsIGFzIG1vdXNlIGV2ZW50cy5cbiAqIFN0YXRlcyBhcmUgdGhlcmUgdG8gZmFjaWxpdGF0aW5nIGludGVyYWN0aW9ucyB3aXRoIHRoZSB0aW1lbGluZSBmb3I6XG4gKiAtIHpvb21pbmdcbiAqIC0gbW92aW5nXG4gKiAtIGVkaXRpbmdcbiAqXG4gKiBNZXRob2RzIGByZWdpc3RlcmAsIGByZW5kZXJgIGFuZCBgdXBkYXRlYCBjYWxsIHRoZSBzYW1lIG1ldGhvZHMgb24gYWxsIHRoZSBgVmlld2AgaW5zdGFuY2VzLCB3aGljaCBjYWxsIHRoZSBzYW1lIG1ldGhvZHMgb25lIG9uIGFsbCBpdHMgYExheWVyYCBpbnN0YW5jZXMuXG4gKiAtIGByZWdpc3RlcmA6IHJlZ2lzdGVycyBhIGBWaWV3YCBpbnN0YW5jZSBvbnRvIHRoZSB0aW1lbGluZSAoaWUuIHRoZSB0aW1lbGluZSBjYW4gYHJlbmRlcmAgYW5kIGB1cGRhdGVgIGl0cyBkaWZmZXJlbnQgdmlld3MpXG4gKiAtIGByZW5kZXJgOiByZW5kZXJzIHRoZSBET00gZm9yIHRoZSBlbGVtZW50IChpZiBoYXMgb25lKSBhbmQgaXRzIGRlc2NlbmRhbnQgKGhlcmUgcmVuZGVycyB0aGUgdmlld3MsIGllLiByZW5kZXIgdGhlIERPTSB0cmVlIGZvciBhIHZpZXcgYW5kIGF0dGFjaCBpdCBpbiB0aGUgRE9NIGF0IHRoZSByaWdodCBwbGFjZSlcbiAqIC0gYHVwZGF0ZWA6IHVwZGF0ZSB0aGUgZGlzcGxheSBhY2NvcmRpbmcgdG8gZGF0YSBjaGFuZ2VzIChpZS4gdXBkYXRlIHRoZSBET00gZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgRE9NIHRyZWUgd2l0aCByZW5kZXIgbWV0aG9kLCBiYXNlZCBvbiBuZXcgZGF0YSkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBUaW1lbGluZWAgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl92aWV3cyA9IG5ldyBWaWV3Q29sbGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVFdmVudCA9IHRoaXMuX2hhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY3JlYXRlSW50ZXJhY3Rpb24oS2V5Ym9hcmQsICdib2R5Jyk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gYWRkIGludGVyYWN0aW9uIG1vZHVsZXMgdGhlIHRpbWVsaW5lIHNob3VsZCBsaXN0ZW4gdG8uXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0aW1lbGluZSBsaXN0ZW4gdG8gS2V5Ym9hcmQsIGFuZCBpbnN0YW5jZSBhIFN1cmZhY2Ugb24gZWFjaCBjb250YWluZXJcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZX0gY3RvciAtIHRoZSBjb250cnVjdG9yIG9mIHRoZSBpbnRlcmFjdGlvbiBtb2R1bGUgdG8gaW5zdGFuY2lhdGVcbiAgICogQHBhcmFtIGVsIHtET01FbGVtZW50fSB0aGUgRE9NIGVsZW1lbnQgdG8gYmluZCB0byB0aGUgRXZlbnRTb3VyY2UgbW9kdWxlXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IG9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgY3RvciAoZGVmYXVsdHMgdG8gYHt9YClcbiAgICovXG4gIF9jcmVhdGVJbnRlcmFjdGlvbihjdG9yLCBlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaW50ZXJhY3Rpb24gPSBuZXcgY3RvcihlbCwgb3B0aW9ucyk7XG4gICAgaW50ZXJhY3Rpb24ub24oJ2V2ZW50JywgdGhpcy5faGFuZGxlRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgdG8gbGlzdGVuIHRvIGludGVyYWN0aW9ucyBtb2R1bGVzXG4gICAqIEBwYXJhbXMge0V2ZW50fSBlIC0gYSBjdXN0b20gZXZlbnQgZ2VuZXJhdGVkIGJ5IGludGVyYWN0aW9uIG1vZHVsZXNcbiAgICovXG4gIF9oYW5kbGVFdmVudChlKSB7XG4gICAgLy8gZW1pdCBldmVudCBhcyBhIG1pZGRsZXdhcmVcbiAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZSk7XG4gICAgLy8gcHJvcGFnYXRlIHRvIHRoZSBzdGF0ZVxuICAgIGlmICghdGhpcy5fc3RhdGUpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fc3RhdGUuaGFuZGxlRXZlbnQoZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBzdGF0ZSBvZiB0aGUgdGltZWxpbmUuXG4gICAqIGBTdGF0ZWAgaW5zdGFuY2VzIGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgYXBwbGljYXRpb24gbG9naWMgYnkgcHJlY2lzaW5nIHNwZWNpZmljIHVzZXIgaW50ZXJhY3Rpb24gY2FzZXMsIGFuZCBob3cgdGhleSBpbXBhY3QgdGhlIG92ZXJhbCB0ZW1wb3JhbCBkYXRhIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VTdGF0ZX0gc3RhdGUgLSB0aGUgc3RhdGUgaW4gd2hpY2ggdGhlIHRpbWVsaW5lIG11c3QgYmUgc2V0dGVkXG4gICAqL1xuICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUpIHsgdGhpcy5fc3RhdGUuZXhpdCgpOyB9XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLl9zdGF0ZS5lbnRlcigpO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldCB2aWV3cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3M7XG4gIH1cblxuICBnZXQgbGF5ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cy5sYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdmlldyB0byB0aGUgdGltZWxpbmVcbiAgICpcbiAgICogVmlld3MgZGlzcGxheSB0aGlzIHdpbmRvdyBvbiB0aGUgdGltZWxpbmUgaW4gdGhlaXJzIERPTSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGFkZCh2aWV3KSB7XG4gICAgdGhpcy52aWV3cy5wdXNoKHZpZXcpO1xuICAgIHRoaXMuX2NyZWF0ZUludGVyYWN0aW9uKFN1cmZhY2UsIHZpZXcuJGVsKTtcbiAgfVxuXG4gIC8vIEBUT0RPXG4gIHJlbW92ZSh2aWV3KSB7XG5cbiAgfVxuXG4gIC8vIEBUT0RPIC0gdmlldyBmYWN0b3J5XG4gIC8vIGhlbHBlcnNcbiAgY29uZmlndXJlVmlld3MocGl4ZWxzUGVyU2Vjb25kID0gMTAwLCB3aWR0aCA9IDEwMDAsIGhlaWdodCA9IDEyMCkge1xuXG4gIH1cblxuICBjcmVhdGVWaWV3KCRlbCwgaWQgPSAnZGVmYXVsdCcsIGhlaWdodCA9IDEyMCkge1xuXG4gIH1cblxuICBhZGRMYXllcihsYXllciwgdmlld0lkID0gJ2RlZmF1bHQnLCBncm91cCA9ICdkZWZhdWx0Jykge1xuXG4gIH1cblxuICByZW1vdmVMYXllcihsYXllcikge1xuXG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQqIHRoaXMudmlld3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG59XG4iXX0=
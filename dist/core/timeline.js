"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _get = require("babel-runtime/helpers/get")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _core = require("babel-runtime/core-js")["default"];

var events = require("events");
var ns = require("./namespace");
var TimeContext = require("./time-context");
var Surface = require("../interactions/surface");
var Keyboard = require("../interactions/keyboard");
var Layer = require("./layer");
var d3Scale = require("d3-scale");

/**
 *  @class Timeline
 */

var Timeline = (function (_events$EventEmitter) {
  /**
   *  Creates a new Timeline
   *  @param params {Object} an object to override defaults parameters
   */

  function Timeline() {
    var params = arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Timeline);

    _get(_core.Object.getPrototypeOf(Timeline.prototype), "constructor", this).call(this);

    this._defaults = {
      width: 1000,
      duration: 60
    };

    // public attributes
    this.params = _core.Object.assign({}, this._defaults, params);
    this.timeContext = null;
    this.layers = [];
    this.containers = {};
    // @NOTE realy needed ?
    this.groupedLayers = {}; // group layer by categories

    // private attributes
    this._state = null;
    this._layerContainerMap = new _core.Map();
    this._handleEvent = this._handleEvent.bind(this);

    this._createTimeContext();
    this._createInteraction(Keyboard, "body");
  }

  _inherits(Timeline, _events$EventEmitter);

  _createClass(Timeline, {
    setState: {

      /**
       *  Change the state of the timeline, `States` are the main entry point between
       *  application logic, interactions, ..., and the library
       *  @param state {BaseState} the state in which the timeline must be setted
       */

      value: function setState(state) {
        if (this._state) {
          this._state.exit();
        }
        this._state = state;
        this._state.enter();
      }
    },
    _handleEvent: {

      /**
       *  @private
       *  The callback that is used to listen to interactions modules
       *  @params e {Event} a custom event generated by interaction modules
       */

      value: function _handleEvent(e) {
        if (!this._state) {
          return;
        }
        this._state.handleEvent(e);
      }
    },
    _createInteraction: {

      /**
       *  Factory method to add interaction modules the timeline should listen to
       *  by default, the timeline listen to Keyboard, and instance a Surface on each
       *  container
       *  @param ctor {EventSource} the contructor of the interaction module to instanciate
       *  @param el {DOMElement} the DOM element to bind to the EventSource module
       */

      value: function _createInteraction(ctor, el) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        var interaction = new ctor(el, options);
        interaction.on("event", this._handleEvent);
      }
    },
    _createTimeContext: {

      /**
       *  Creates a new TimeContext for the visualisation, this `TimeContext`
       *  will be at the top of the `TimeContext` tree
       */

      value: function _createTimeContext() {
        var duration = this.params.duration;
        var width = this.params.width;

        var xScale = d3Scale.linear().domain([0, duration]).range([0, width]);

        this.timeContext = new TimeContext();
        this.timeContext.duration = duration;
        this.timeContext.xScale = xScale;
      }
    },
    addLayer: {

      /**
       *  Adds a `Layer` to the Timeline
       *  @param layer {Layer} the layer to register
       *  @param containerId {String} a valid id of a previsouly registered container
       *  @param group {String} insert the layer into some user defined group of layers
       *  @param timeContext {TimeContext} a `TimeContext` the layer is associated with
       *      if null given, a new `TimeContext` will be created for the layer
       */

      value: function addLayer(layer, containerId) {
        var group = arguments[2] === undefined ? "default" : arguments[2];

        this._layerContainerMap.set(layer, this.containers[containerId]);
        this.layers.push(layer);

        if (!this.groupedLayers[group]) {
          this.groupedLayers[group] = [];
        }

        this.groupedLayers[group].push(layer);
      }
    },
    removeLayer: {

      /**
       *  Remove a layer from the timeline
       *  @param layer {Layer} the layer to remove
       */

      value: function removeLayer(layer) {}
    },
    getGroup: {

      // @NOTE bad API => method name
      /**
       *  Returns an array of layers given some group
       *  @param group {String} name of the group
       *  @return {Array} an array of layers which belongs to the group
       */

      value: function getGroup() {
        var group = arguments[0] === undefined ? "default" : arguments[0];

        return this.groupedLayers[group] || [];
      }
    },
    registerContainer: {

      /**
       *  Register a container and prepare the DOM svg element for the timeline's layers
       *  @param id {String} a user defined id for the container
       *  @param el {DOMElement} the DOMElement to use as a container
       *  @param options {Object} the options to apply to the container
       */

      value: function registerContainer(id, el) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        var width = this.params.width;
        var height = options.height || 120;

        var svg = document.createElementNS(ns, "svg");
        svg.setAttributeNS(null, "width", width);
        svg.setAttributeNS(null, "height", height);
        svg.setAttributeNS(null, "viewbox", "0 0 " + width + " " + height);

        svg.setAttributeNS(null, "shape-rendering", "optimizeSpeed");

        // svg.setAttributeNS(ns, 'xmlns', ns);
        svg.setAttribute("xmlns:xhtml", "http://www.w3.org/1999/xhtml");

        var defs = document.createElementNS(ns, "defs");

        var offsetGroup = document.createElementNS(ns, "g");
        offsetGroup.classList.add("offset");

        var layoutGroup = document.createElementNS(ns, "g");
        layoutGroup.classList.add("layout");

        var interactionsGroup = document.createElementNS(ns, "g");
        interactionsGroup.classList.add("interactions");

        svg.appendChild(defs);
        offsetGroup.appendChild(layoutGroup);
        svg.appendChild(offsetGroup);
        svg.appendChild(interactionsGroup);

        el.appendChild(svg);
        el.style.fontSize = 0; // removes additionnal height added who knows why...
        el.style.transform = "translateZ(0)"; // fixes one of the weird canvas rendering bugs in chrome

        // store all informations about this container
        var container = {
          id: id,
          layoutElement: layoutGroup,
          offsetElement: offsetGroup,
          interactionsElement: interactionsGroup,
          svgElement: svg,
          DOMElement: el,
          brushElement: null
        };

        this.containers[id] = container;
        this._createInteraction(Surface, el);
      }
    },
    getContainerPerElement: {

      // @NOTE remove these helpers ?
      // container helpers
      // @NOTE change to `getContainer(el || id || layer)` ?

      value: function getContainerPerElement(el) {
        for (var id in this.containers) {
          var container = this.containers[id];
          if (container.DOMElement === el) {
            return container;
          }
        }

        return null;
      }
    },
    getLayerContainer: {
      value: function getLayerContainer(layer) {
        return this._layerContainerMap.get(layer);
      }
    },
    _getLayers: {

      // getContainerPerId(id) {
      //   return this.containers[id];
      // }

      /**
       *  @param LayerOrGroup{mixed} defaults null
       *  @return an array of layers
       */

      value: function _getLayers() {
        var layerOrGroup = arguments[0] === undefined ? null : arguments[0];

        var layers = null;

        if (typeof layerOrGroup === "string") {
          layers = this.getLayers(layerOrGroup);
        } else if (layerOrGroup instanceof Layer) {
          layers = [layerOrGroup];
        } else {
          layers = this.layers;
        }

        return layers;
      }
    },
    updateContainers: {

      /**
       *  Update all the containers according to `this.timeContext`
       */

      value: function updateContainers() {
        for (var id in this.containers) {
          var container = this.containers[id];
          var offset = container.offsetElement;
          var timeContext = this.timeContext;
          var translate = "translate(" + timeContext.xScale(timeContext.offset) + ", 0)";
          offset.setAttributeNS(null, "transform", translate);
        }
      }
    },
    render: {

      /**
       *  Render all the layers in the timeline
       */

      value: function render() {
        var _this = this;

        this.layers.forEach(function (layer) {
          var container = _this._layerContainerMap.get(layer);
          container.layoutElement.appendChild(layer.render());
        });
      }
    },
    draw: {

      /**
       *  Draw all the layers in the timeline
       */

      value: function draw() {
        var layerOrGroup = arguments[0] === undefined ? null : arguments[0];

        var layers = this._getLayers(layerOrGroup);
        layers.forEach(function (layer) {
          return layer.draw();
        });
      }
    },
    update: {

      /**
       *  Update all the layers in the timeline
       *  @TODO accept several `layers` or `categories` as arguments ?
       */

      value: function update() {
        var layerOrGroup = arguments[0] === undefined ? null : arguments[0];

        var layers = this._getLayers(layerOrGroup);
        this.updateContainers();

        layers.forEach(function (layer) {
          return layer.update();
        });
        this.emit("update", layers);
      }
    }
  });

  return Timeline;
})(events.EventEmitter);

module.exports = Timeline;
//# sourceMappingURL=data:application/json;base64,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VyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ3JELENBQUMsQ0FBQztPQUNKOztBQUtELFFBQUk7Ozs7OzthQUFBLGdCQUFzQjtZQUFyQixZQUFZLGdDQUFHLElBQUk7O0FBQ3RCLFlBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDN0MsY0FBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUs7aUJBQUssS0FBSyxDQUFDLElBQUksRUFBRTtTQUFBLENBQUMsQ0FBQztPQUN6Qzs7QUFNRCxVQUFNOzs7Ozs7O2FBQUEsa0JBQXNCO1lBQXJCLFlBQVksZ0NBQUcsSUFBSTs7QUFDeEIsWUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUM3QyxZQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQzs7QUFFeEIsY0FBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUs7aUJBQUssS0FBSyxDQUFDLE1BQU0sRUFBRTtTQUFBLENBQUMsQ0FBQztBQUMxQyxZQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztPQUM3Qjs7OztTQTVQRyxRQUFRO0dBQVMsTUFBTSxDQUFDLFlBQVk7O0FBK1AxQyxNQUFNLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyIsImZpbGUiOiJlczYvY29yZS90aW1lbGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgbnMgPSByZXF1aXJlKCcuL25hbWVzcGFjZScpO1xuY29uc3QgVGltZUNvbnRleHQgPSByZXF1aXJlKCcuL3RpbWUtY29udGV4dCcpO1xuY29uc3QgU3VyZmFjZSAgPSByZXF1aXJlKCcuLi9pbnRlcmFjdGlvbnMvc3VyZmFjZScpO1xuY29uc3QgS2V5Ym9hcmQgPSByZXF1aXJlKCcuLi9pbnRlcmFjdGlvbnMva2V5Ym9hcmQnKTtcbmNvbnN0IExheWVyID0gcmVxdWlyZSgnLi9sYXllcicpO1xuY29uc3QgZDNTY2FsZSA9IHJlcXVpcmUoJ2QzLXNjYWxlJyk7XG5cbi8qKlxuICogIEBjbGFzcyBUaW1lbGluZVxuICovXG5jbGFzcyBUaW1lbGluZSBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogIENyZWF0ZXMgYSBuZXcgVGltZWxpbmVcbiAgICogIEBwYXJhbSBwYXJhbXMge09iamVjdH0gYW4gb2JqZWN0IHRvIG92ZXJyaWRlIGRlZmF1bHRzIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuICAgICAgd2lkdGg6IDEwMDAsXG4gICAgICBkdXJhdGlvbjogNjBcbiAgICB9O1xuXG4gICAgLy8gcHVibGljIGF0dHJpYnV0ZXNcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHRoaXMudGltZUNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgdGhpcy5jb250YWluZXJzID0ge307XG4gICAgLy8gQE5PVEUgcmVhbHkgbmVlZGVkID9cbiAgICB0aGlzLmdyb3VwZWRMYXllcnMgPSB7fTsgLy8gZ3JvdXAgbGF5ZXIgYnkgY2F0ZWdvcmllc1xuXG4gICAgLy8gcHJpdmF0ZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX2xheWVyQ29udGFpbmVyTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2hhbmRsZUV2ZW50ID0gdGhpcy5faGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NyZWF0ZVRpbWVDb250ZXh0KCk7XG4gICAgdGhpcy5fY3JlYXRlSW50ZXJhY3Rpb24oS2V5Ym9hcmQsICdib2R5Jyk7XG4gIH1cblxuICAvKipcbiAgICogIENoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIHRpbWVsaW5lLCBgU3RhdGVzYCBhcmUgdGhlIG1haW4gZW50cnkgcG9pbnQgYmV0d2VlblxuICAgKiAgYXBwbGljYXRpb24gbG9naWMsIGludGVyYWN0aW9ucywgLi4uLCBhbmQgdGhlIGxpYnJhcnlcbiAgICogIEBwYXJhbSBzdGF0ZSB7QmFzZVN0YXRlfSB0aGUgc3RhdGUgaW4gd2hpY2ggdGhlIHRpbWVsaW5lIG11c3QgYmUgc2V0dGVkXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSkgeyB0aGlzLl9zdGF0ZS5leGl0KCk7IH1cbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX3N0YXRlLmVudGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogIEBwcml2YXRlXG4gICAqICBUaGUgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHRvIGxpc3RlbiB0byBpbnRlcmFjdGlvbnMgbW9kdWxlc1xuICAgKiAgQHBhcmFtcyBlIHtFdmVudH0gYSBjdXN0b20gZXZlbnQgZ2VuZXJhdGVkIGJ5IGludGVyYWN0aW9uIG1vZHVsZXNcbiAgICovXG4gIF9oYW5kbGVFdmVudChlKSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZSkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9zdGF0ZS5oYW5kbGVFdmVudChlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgRmFjdG9yeSBtZXRob2QgdG8gYWRkIGludGVyYWN0aW9uIG1vZHVsZXMgdGhlIHRpbWVsaW5lIHNob3VsZCBsaXN0ZW4gdG9cbiAgICogIGJ5IGRlZmF1bHQsIHRoZSB0aW1lbGluZSBsaXN0ZW4gdG8gS2V5Ym9hcmQsIGFuZCBpbnN0YW5jZSBhIFN1cmZhY2Ugb24gZWFjaFxuICAgKiAgY29udGFpbmVyXG4gICAqICBAcGFyYW0gY3RvciB7RXZlbnRTb3VyY2V9IHRoZSBjb250cnVjdG9yIG9mIHRoZSBpbnRlcmFjdGlvbiBtb2R1bGUgdG8gaW5zdGFuY2lhdGVcbiAgICogIEBwYXJhbSBlbCB7RE9NRWxlbWVudH0gdGhlIERPTSBlbGVtZW50IHRvIGJpbmQgdG8gdGhlIEV2ZW50U291cmNlIG1vZHVsZVxuICAgKi9cbiAgX2NyZWF0ZUludGVyYWN0aW9uKGN0b3IsIGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpbnRlcmFjdGlvbiA9IG5ldyBjdG9yKGVsLCBvcHRpb25zKTtcbiAgICBpbnRlcmFjdGlvbi5vbignZXZlbnQnLCB0aGlzLl9oYW5kbGVFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogIENyZWF0ZXMgYSBuZXcgVGltZUNvbnRleHQgZm9yIHRoZSB2aXN1YWxpc2F0aW9uLCB0aGlzIGBUaW1lQ29udGV4dGBcbiAgICogIHdpbGwgYmUgYXQgdGhlIHRvcCBvZiB0aGUgYFRpbWVDb250ZXh0YCB0cmVlXG4gICAqL1xuICBfY3JlYXRlVGltZUNvbnRleHQoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnBhcmFtcy5kdXJhdGlvbjtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMucGFyYW1zLndpZHRoO1xuXG4gICAgY29uc3QgeFNjYWxlID0gZDNTY2FsZS5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgZHVyYXRpb25dKVxuICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdGhpcy50aW1lQ29udGV4dCA9IG5ldyBUaW1lQ29udGV4dCgpO1xuICAgIHRoaXMudGltZUNvbnRleHQuZHVyYXRpb24gPSAgZHVyYXRpb247XG4gICAgdGhpcy50aW1lQ29udGV4dC54U2NhbGUgPSB4U2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogIEFkZHMgYSBgTGF5ZXJgIHRvIHRoZSBUaW1lbGluZVxuICAgKiAgQHBhcmFtIGxheWVyIHtMYXllcn0gdGhlIGxheWVyIHRvIHJlZ2lzdGVyXG4gICAqICBAcGFyYW0gY29udGFpbmVySWQge1N0cmluZ30gYSB2YWxpZCBpZCBvZiBhIHByZXZpc291bHkgcmVnaXN0ZXJlZCBjb250YWluZXJcbiAgICogIEBwYXJhbSBncm91cCB7U3RyaW5nfSBpbnNlcnQgdGhlIGxheWVyIGludG8gc29tZSB1c2VyIGRlZmluZWQgZ3JvdXAgb2YgbGF5ZXJzXG4gICAqICBAcGFyYW0gdGltZUNvbnRleHQge1RpbWVDb250ZXh0fSBhIGBUaW1lQ29udGV4dGAgdGhlIGxheWVyIGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgKiAgICAgIGlmIG51bGwgZ2l2ZW4sIGEgbmV3IGBUaW1lQ29udGV4dGAgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgbGF5ZXJcbiAgICovXG4gIGFkZExheWVyKGxheWVyLCBjb250YWluZXJJZCwgZ3JvdXAgPSAnZGVmYXVsdCcpIHtcbiAgICB0aGlzLl9sYXllckNvbnRhaW5lck1hcC5zZXQobGF5ZXIsIHRoaXMuY29udGFpbmVyc1tjb250YWluZXJJZF0pO1xuICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuXG4gICAgaWYgKCF0aGlzLmdyb3VwZWRMYXllcnNbZ3JvdXBdKSB7XG4gICAgICB0aGlzLmdyb3VwZWRMYXllcnNbZ3JvdXBdID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5ncm91cGVkTGF5ZXJzW2dyb3VwXS5wdXNoKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmVtb3ZlIGEgbGF5ZXIgZnJvbSB0aGUgdGltZWxpbmVcbiAgICogIEBwYXJhbSBsYXllciB7TGF5ZXJ9IHRoZSBsYXllciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG5cbiAgfVxuXG4gIC8vIEBOT1RFIGJhZCBBUEkgPT4gbWV0aG9kIG5hbWVcbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IG9mIGxheWVycyBnaXZlbiBzb21lIGdyb3VwXG4gICAqICBAcGFyYW0gZ3JvdXAge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3JvdXBcbiAgICogIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBsYXllcnMgd2hpY2ggYmVsb25ncyB0byB0aGUgZ3JvdXBcbiAgICovXG4gIGdldEdyb3VwKGdyb3VwID0gJ2RlZmF1bHQnKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBlZExheWVyc1tncm91cF0gfHzCoFtdO1xuICB9XG5cbiAgLyoqXG4gICAqICBSZWdpc3RlciBhIGNvbnRhaW5lciBhbmQgcHJlcGFyZSB0aGUgRE9NIHN2ZyBlbGVtZW50IGZvciB0aGUgdGltZWxpbmUncyBsYXllcnNcbiAgICogIEBwYXJhbSBpZCB7U3RyaW5nfSBhIHVzZXIgZGVmaW5lZCBpZCBmb3IgdGhlIGNvbnRhaW5lclxuICAgKiAgQHBhcmFtIGVsIHtET01FbGVtZW50fSB0aGUgRE9NRWxlbWVudCB0byB1c2UgYXMgYSBjb250YWluZXJcbiAgICogIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IHRoZSBvcHRpb25zIHRvIGFwcGx5IHRvIHRoZSBjb250YWluZXJcbiAgICovXG4gIHJlZ2lzdGVyQ29udGFpbmVyKGlkLCBlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLnBhcmFtcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAxMjA7XG5cbiAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdzdmcnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgd2lkdGgpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3ZpZXdib3gnLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuXG4gICAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzaGFwZS1yZW5kZXJpbmcnLCAnb3B0aW1pemVTcGVlZCcpO1xuXG4gICAgLy8gc3ZnLnNldEF0dHJpYnV0ZU5TKG5zLCAneG1sbnMnLCBucyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnM6eGh0bWwnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcpO1xuXG4gICAgY29uc3QgZGVmcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ2RlZnMnKTtcblxuICAgIGNvbnN0IG9mZnNldEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnZycpO1xuICAgIG9mZnNldEdyb3VwLmNsYXNzTGlzdC5hZGQoJ29mZnNldCcpO1xuXG4gICAgY29uc3QgbGF5b3V0R3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdnJyk7XG4gICAgbGF5b3V0R3JvdXAuY2xhc3NMaXN0LmFkZCgnbGF5b3V0Jyk7XG5cbiAgICBjb25zdCBpbnRlcmFjdGlvbnNHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ2cnKTtcbiAgICBpbnRlcmFjdGlvbnNHcm91cC5jbGFzc0xpc3QuYWRkKCdpbnRlcmFjdGlvbnMnKTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICBvZmZzZXRHcm91cC5hcHBlbmRDaGlsZChsYXlvdXRHcm91cCk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKG9mZnNldEdyb3VwKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQoaW50ZXJhY3Rpb25zR3JvdXApO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICBlbC5zdHlsZS5mb250U2l6ZSA9IDA7IC8vIHJlbW92ZXMgYWRkaXRpb25uYWwgaGVpZ2h0IGFkZGVkIHdobyBrbm93cyB3aHkuLi5cbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7IC8vIGZpeGVzIG9uZSBvZiB0aGUgd2VpcmQgY2FudmFzIHJlbmRlcmluZyBidWdzIGluIGNocm9tZVxuXG4gICAgLy8gc3RvcmUgYWxsIGluZm9ybWF0aW9ucyBhYm91dCB0aGlzIGNvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxheW91dEVsZW1lbnQ6IGxheW91dEdyb3VwLFxuICAgICAgb2Zmc2V0RWxlbWVudDogb2Zmc2V0R3JvdXAsXG4gICAgICBpbnRlcmFjdGlvbnNFbGVtZW50OiBpbnRlcmFjdGlvbnNHcm91cCxcbiAgICAgIHN2Z0VsZW1lbnQ6IHN2ZyxcbiAgICAgIERPTUVsZW1lbnQ6IGVsLFxuICAgICAgYnJ1c2hFbGVtZW50OiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuY29udGFpbmVyc1tpZF0gPSBjb250YWluZXI7XG4gICAgdGhpcy5fY3JlYXRlSW50ZXJhY3Rpb24oU3VyZmFjZSwgZWwpO1xuICB9XG5cbiAgLy8gQE5PVEUgcmVtb3ZlIHRoZXNlIGhlbHBlcnMgP1xuICAvLyBjb250YWluZXIgaGVscGVyc1xuICAvLyBATk9URSBjaGFuZ2UgdG8gYGdldENvbnRhaW5lcihlbCB8fCBpZCB8fCBsYXllcilgID9cbiAgZ2V0Q29udGFpbmVyUGVyRWxlbWVudChlbCkge1xuICAgIGZvciAobGV0IGlkIGluIHRoaXMuY29udGFpbmVycykge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJzW2lkXTtcbiAgICAgIGlmIChjb250YWluZXIuRE9NRWxlbWVudCA9PT0gZWwpIHsgcmV0dXJuIGNvbnRhaW5lcjsgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0TGF5ZXJDb250YWluZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJDb250YWluZXJNYXAuZ2V0KGxheWVyKTtcbiAgfVxuXG4gIC8vIGdldENvbnRhaW5lclBlcklkKGlkKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuY29udGFpbmVyc1tpZF07XG4gIC8vIH1cblxuXG4gIC8qKlxuICAgKiAgQHBhcmFtIExheWVyT3JHcm91cHttaXhlZH0gZGVmYXVsdHMgbnVsbFxuICAgKiAgQHJldHVybiBhbiBhcnJheSBvZiBsYXllcnNcbiAgICovXG4gIF9nZXRMYXllcnMobGF5ZXJPckdyb3VwID0gbnVsbCkge1xuICAgIGxldCBsYXllcnMgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBsYXllck9yR3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsYXllcnMgPSB0aGlzLmdldExheWVycyhsYXllck9yR3JvdXApO1xuICAgIH0gZWxzZSBpZiAobGF5ZXJPckdyb3VwIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgIGxheWVycyA9IFtsYXllck9yR3JvdXBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMgPSB0aGlzLmxheWVycztcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqICBVcGRhdGUgYWxsIHRoZSBjb250YWluZXJzIGFjY29yZGluZyB0byBgdGhpcy50aW1lQ29udGV4dGBcbiAgICovXG4gIHVwZGF0ZUNvbnRhaW5lcnMoKSB7XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5jb250YWluZXJzKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaWRdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gY29udGFpbmVyLm9mZnNldEVsZW1lbnQ7XG4gICAgICBjb25zdCB0aW1lQ29udGV4dCA9IHRoaXMudGltZUNvbnRleHQ7XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSBgdHJhbnNsYXRlKCR7dGltZUNvbnRleHQueFNjYWxlKHRpbWVDb250ZXh0Lm9mZnNldCl9LCAwKWA7XG4gICAgICBvZmZzZXQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBSZW5kZXIgYWxsIHRoZSBsYXllcnMgaW4gdGhlIHRpbWVsaW5lXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2xheWVyQ29udGFpbmVyTWFwLmdldChsYXllcik7XG4gICAgICBjb250YWluZXIubGF5b3V0RWxlbWVudC5hcHBlbmRDaGlsZChsYXllci5yZW5kZXIoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogIERyYXcgYWxsIHRoZSBsYXllcnMgaW4gdGhlIHRpbWVsaW5lXG4gICAqL1xuICBkcmF3KGxheWVyT3JHcm91cCA9IG51bGwpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9nZXRMYXllcnMobGF5ZXJPckdyb3VwKTtcbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IGxheWVyLmRyYXcoKSk7XG4gIH1cblxuICAvKipcbiAgICogIFVwZGF0ZSBhbGwgdGhlIGxheWVycyBpbiB0aGUgdGltZWxpbmVcbiAgICogIEBUT0RPIGFjY2VwdCBzZXZlcmFsIGBsYXllcnNgIG9yIGBjYXRlZ29yaWVzYCBhcyBhcmd1bWVudHMgP1xuICAgKi9cbiAgdXBkYXRlKGxheWVyT3JHcm91cCA9IG51bGwpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9nZXRMYXllcnMobGF5ZXJPckdyb3VwKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lcnMoKTtcblxuICAgIGxheWVycy5mb3JFYWNoKChsYXllcikgPT4gbGF5ZXIudXBkYXRlKCkpO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbGF5ZXJzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lO1xuIl19
"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _get = require("babel-runtime/helpers/get")["default"];

var _createComputedClass = require("babel-runtime/helpers/create-computed-class")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequire = require("babel-runtime/helpers/interop-require")["default"];

var d3Scale = _interopRequire(require("d3-scale"));

var events = _interopRequire(require("events"));

var Keyboard = _interopRequire(require("../interactions/keyboard"));

var Surface = _interopRequire(require("../interactions/surface"));

var View = _interopRequire(require("./view"));

var ViewCollection = _interopRequire(require("./view-collection"));

/**
 * The `Timeline` class is the main entry point to create a representation of temporal data.
 * A `Timeline` instance can have multiples `View` instances, which are basically a view window on the overall timeline.
 *
 * The timeline hold the current interaction state and is the central hub for keyboard as well as mouse events.
 * States are there to facilitating interactions with the timeline for:
 * - zooming
 * - moving
 * - editing
 *
 * Methods `register`, `render` and `update` call the same methods on all the `View` instances, which call the same methods one on all its `Layer` instances.
 * - `register`: registers a `View` instance onto the timeline (ie. the timeline can `render` and `update` its different views)
 * - `render`: renders the DOM for the element (if has one) and its descendant (here renders the views, ie. render the DOM tree for a view and attach it in the DOM at the right place)
 * - `update`: update the display according to data changes (ie. update the DOM element attached to the DOM tree with render method, based on new data).
 */

var BaseTimeline = (function (_events$EventEmitter) {
  /**
   * Creates a new `Timeline` instance
   */

  function BaseTimeline() {
    _classCallCheck(this, BaseTimeline);

    _get(_core.Object.getPrototypeOf(BaseTimeline.prototype), "constructor", this).call(this);

    this.views = new ViewCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, "body");
  }

  _inherits(BaseTimeline, _events$EventEmitter);

  _createComputedClass(BaseTimeline, [{
    key: "_createInteraction",

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline listen to Keyboard, and instance a Surface on each container
     * @param {EventSource} ctor - the contructor of the interaction module to instanciate
     * @param el {DOMElement} the DOM element to bind to the EventSource module
     * @param options {Object} options to be applied to the ctor (defaults to `{}`)
     */
    value: function _createInteraction(ctor, el) {
      var options = arguments[2] === undefined ? {} : arguments[2];

      var interaction = new ctor(el, options);
      interaction.on("event", this._handleEvent);
    }
  }, {
    key: "state",

    /**
     * Changes the state of the timeline.
     * `State` instances are used to define the application logic by precising specific user interaction cases, and how they impact the overal temporal data representation.
     *
     * @param {BaseState} state - the state in which the timeline must be setted
     */
    set: function (state) {
      if (this._state) {
        this._state.exit();
      }
      this._state = state;
      this._state.enter();
    },
    get: function () {
      return this._state;
    }
  }, {
    key: "_handleEvent",

    /**
     * The callback that is used to listen to interactions modules
     * @params {Event} e - a custom event generated by interaction modules
     */
    value: function _handleEvent(e) {
      // emit event as a middleware
      this.emit("event", e);
      // propagate to the state
      if (!this._state) {
        return;
      }
      this._state.handleEvent(e);
    }
  }, {
    key: "register",

    /**
     * Add a view to the timeline
     *
     * Views display this window on the timeline in theirs DOM SVG element.
     */
    value: function register(view) {
      this.views.push(view);
      this._createInteraction(Surface, view.$el);
    }
  }, {
    key: _core.Symbol.iterator,
    value: _regeneratorRuntime.mark(function callee$1$0() {
      var _this = this;

      return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_core.$for.getIterator(_this.views), "t106", 1);

          case 1:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    })
  }]);

  return BaseTimeline;
})(events.EventEmitter);

module.exports = BaseTimeline;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVzNi9jb3JlL2Jhc2UtdGltZWxpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQUFPLE9BQU8sMkJBQU0sVUFBVTs7SUFDdkIsTUFBTSwyQkFBTSxRQUFROztJQUVwQixRQUFRLDJCQUFNLDBCQUEwQjs7SUFDeEMsT0FBTywyQkFBTSx5QkFBeUI7O0lBQ3RDLElBQUksMkJBQU0sUUFBUTs7SUFDbEIsY0FBYywyQkFBTSxtQkFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWtCekIsWUFBWTs7Ozs7QUFJcEIsV0FKUSxZQUFZLEdBSWpCOzBCQUpLLFlBQVk7O0FBSzdCLHFDQUxpQixZQUFZLDZDQUtyQjs7QUFFUixRQUFJLENBQUMsS0FBSyxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV0QyxRQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNuQixRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pELFFBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7R0FDM0M7O1lBWmtCLFlBQVk7O3VCQUFaLFlBQVk7Ozs7Ozs7Ozs7V0FxQmIsNEJBQUMsSUFBSSxFQUFFLEVBQUUsRUFBZ0I7VUFBZCxPQUFPLGdDQUFHLEVBQUU7O0FBQ3ZDLFVBQU0sV0FBVyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMxQyxpQkFBVyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzVDOzs7Ozs7Ozs7O1NBUVEsVUFBQyxLQUFLLEVBQUU7QUFDZixVQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFBRSxZQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO09BQUU7QUFDeEMsVUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7QUFDcEIsVUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNyQjtTQUVRLFlBQUU7QUFDVCxhQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7S0FDcEI7Ozs7Ozs7O1dBTVcsc0JBQUMsQ0FBQyxFQUFFOztBQUVkLFVBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUV0QixVQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUFFLGVBQU87T0FBRTtBQUM3QixVQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM1Qjs7Ozs7Ozs7O1dBT08sa0JBQUMsSUFBSSxFQUFFO0FBQ2IsVUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsVUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDNUM7O1NBRUMsTUFBQSxNQUFNLENBQUMsUUFBUTtvQ0FBQzs7Ozs7O29FQUNULE1BQUssS0FBSzs7Ozs7OztLQUNsQjs7O1NBbEVrQixZQUFZO0dBQVMsTUFBTSxDQUFDLFlBQVk7O2lCQUF4QyxZQUFZIiwiZmlsZSI6ImVzNi9jb3JlL2Jhc2UtdGltZWxpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZDNTY2FsZSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5cbmltcG9ydCBLZXlib2FyZCBmcm9tICcuLi9pbnRlcmFjdGlvbnMva2V5Ym9hcmQnO1xuaW1wb3J0IFN1cmZhY2UgZnJvbSAnLi4vaW50ZXJhY3Rpb25zL3N1cmZhY2UnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi92aWV3JztcbmltcG9ydCBWaWV3Q29sbGVjdGlvbiBmcm9tICcuL3ZpZXctY29sbGVjdGlvbic7XG5cblxuLyoqXG4gKiBUaGUgYFRpbWVsaW5lYCBjbGFzcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCB0byBjcmVhdGUgYSByZXByZXNlbnRhdGlvbiBvZiB0ZW1wb3JhbCBkYXRhLlxuICogQSBgVGltZWxpbmVgIGluc3RhbmNlIGNhbiBoYXZlIG11bHRpcGxlcyBgVmlld2AgaW5zdGFuY2VzLCB3aGljaCBhcmUgYmFzaWNhbGx5IGEgdmlldyB3aW5kb3cgb24gdGhlIG92ZXJhbGwgdGltZWxpbmUuXG4gKlxuICogVGhlIHRpbWVsaW5lIGhvbGQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gc3RhdGUgYW5kIGlzIHRoZSBjZW50cmFsIGh1YiBmb3Iga2V5Ym9hcmQgYXMgd2VsbCBhcyBtb3VzZSBldmVudHMuXG4gKiBTdGF0ZXMgYXJlIHRoZXJlIHRvIGZhY2lsaXRhdGluZyBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdGltZWxpbmUgZm9yOlxuICogLSB6b29taW5nXG4gKiAtIG1vdmluZ1xuICogLSBlZGl0aW5nXG4gKlxuICogTWV0aG9kcyBgcmVnaXN0ZXJgLCBgcmVuZGVyYCBhbmQgYHVwZGF0ZWAgY2FsbCB0aGUgc2FtZSBtZXRob2RzIG9uIGFsbCB0aGUgYFZpZXdgIGluc3RhbmNlcywgd2hpY2ggY2FsbCB0aGUgc2FtZSBtZXRob2RzIG9uZSBvbiBhbGwgaXRzIGBMYXllcmAgaW5zdGFuY2VzLlxuICogLSBgcmVnaXN0ZXJgOiByZWdpc3RlcnMgYSBgVmlld2AgaW5zdGFuY2Ugb250byB0aGUgdGltZWxpbmUgKGllLiB0aGUgdGltZWxpbmUgY2FuIGByZW5kZXJgIGFuZCBgdXBkYXRlYCBpdHMgZGlmZmVyZW50IHZpZXdzKVxuICogLSBgcmVuZGVyYDogcmVuZGVycyB0aGUgRE9NIGZvciB0aGUgZWxlbWVudCAoaWYgaGFzIG9uZSkgYW5kIGl0cyBkZXNjZW5kYW50IChoZXJlIHJlbmRlcnMgdGhlIHZpZXdzLCBpZS4gcmVuZGVyIHRoZSBET00gdHJlZSBmb3IgYSB2aWV3IGFuZCBhdHRhY2ggaXQgaW4gdGhlIERPTSBhdCB0aGUgcmlnaHQgcGxhY2UpXG4gKiAtIGB1cGRhdGVgOiB1cGRhdGUgdGhlIGRpc3BsYXkgYWNjb3JkaW5nIHRvIGRhdGEgY2hhbmdlcyAoaWUuIHVwZGF0ZSB0aGUgRE9NIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIERPTSB0cmVlIHdpdGggcmVuZGVyIG1ldGhvZCwgYmFzZWQgb24gbmV3IGRhdGEpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlVGltZWxpbmUgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFRpbWVsaW5lYCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMudmlld3MgPSBuZXcgVmlld0NvbGxlY3Rpb24odGhpcyk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlRXZlbnQgPSB0aGlzLl9oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NyZWF0ZUludGVyYWN0aW9uKEtleWJvYXJkLCAnYm9keScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGFkZCBpbnRlcmFjdGlvbiBtb2R1bGVzIHRoZSB0aW1lbGluZSBzaG91bGQgbGlzdGVuIHRvLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgdGltZWxpbmUgbGlzdGVuIHRvIEtleWJvYXJkLCBhbmQgaW5zdGFuY2UgYSBTdXJmYWNlIG9uIGVhY2ggY29udGFpbmVyXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2V9IGN0b3IgLSB0aGUgY29udHJ1Y3RvciBvZiB0aGUgaW50ZXJhY3Rpb24gbW9kdWxlIHRvIGluc3RhbmNpYXRlXG4gICAqIEBwYXJhbSBlbCB7RE9NRWxlbWVudH0gdGhlIERPTSBlbGVtZW50IHRvIGJpbmQgdG8gdGhlIEV2ZW50U291cmNlIG1vZHVsZVxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBvcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGN0b3IgKGRlZmF1bHRzIHRvIGB7fWApXG4gICAqL1xuICBfY3JlYXRlSW50ZXJhY3Rpb24oY3RvciwgZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGludGVyYWN0aW9uID0gbmV3IGN0b3IoZWwsIG9wdGlvbnMpO1xuICAgIGludGVyYWN0aW9uLm9uKCdldmVudCcsIHRoaXMuX2hhbmRsZUV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBzdGF0ZSBvZiB0aGUgdGltZWxpbmUuXG4gICAqIGBTdGF0ZWAgaW5zdGFuY2VzIGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgYXBwbGljYXRpb24gbG9naWMgYnkgcHJlY2lzaW5nIHNwZWNpZmljIHVzZXIgaW50ZXJhY3Rpb24gY2FzZXMsIGFuZCBob3cgdGhleSBpbXBhY3QgdGhlIG92ZXJhbCB0ZW1wb3JhbCBkYXRhIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VTdGF0ZX0gc3RhdGUgLSB0aGUgc3RhdGUgaW4gd2hpY2ggdGhlIHRpbWVsaW5lIG11c3QgYmUgc2V0dGVkXG4gICAqL1xuICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUpIHsgdGhpcy5fc3RhdGUuZXhpdCgpOyB9XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLl9zdGF0ZS5lbnRlcigpO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCl7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgdG8gbGlzdGVuIHRvIGludGVyYWN0aW9ucyBtb2R1bGVzXG4gICAqIEBwYXJhbXMge0V2ZW50fSBlIC0gYSBjdXN0b20gZXZlbnQgZ2VuZXJhdGVkIGJ5IGludGVyYWN0aW9uIG1vZHVsZXNcbiAgICovXG4gIF9oYW5kbGVFdmVudChlKSB7XG4gICAgLy8gZW1pdCBldmVudCBhcyBhIG1pZGRsZXdhcmVcbiAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZSk7XG4gICAgLy8gcHJvcGFnYXRlIHRvIHRoZSBzdGF0ZVxuICAgIGlmICghdGhpcy5fc3RhdGUpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fc3RhdGUuaGFuZGxlRXZlbnQoZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdmlldyB0byB0aGUgdGltZWxpbmVcbiAgICpcbiAgICogVmlld3MgZGlzcGxheSB0aGlzIHdpbmRvdyBvbiB0aGUgdGltZWxpbmUgaW4gdGhlaXJzIERPTSBTVkcgZWxlbWVudC5cbiAgICovXG4gIHJlZ2lzdGVyKHZpZXcpIHtcbiAgICB0aGlzLnZpZXdzLnB1c2godmlldyk7XG4gICAgdGhpcy5fY3JlYXRlSW50ZXJhY3Rpb24oU3VyZmFjZSwgdmlldy4kZWwpO1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkKiB0aGlzLnZpZXdzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufVxuIl19